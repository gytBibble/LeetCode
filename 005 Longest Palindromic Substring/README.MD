# 题目
* 最长的回文子串
# 思路
1. 考虑暴力解决法，假设字符串长度为`n`，则一共有`n(n-1)/2`种子串，判断一个字符串是否为回文需要花费`O(n)`的时间，则这个方法的时间复杂度为`O(n^3)`，空间复杂度为`O(1)`

2. 理解了回文之后，可以先把原字符`S`串翻转得到`S'`，找出`S`和`S'`的最长公共字串即最长的回文子串，事实上，还存在一个问题，如果`S = abcdefdcba`，那么`S`和`S'`的最长子串是`abcd`，并不是回文串。所以找到一个最长公共子串时，还需要检查子串的索引是否与反向子串原始的索引相同，如果相同，则找到最长回文子串。  
参考：[最长公共子序列和最长公共子串](https://blog.csdn.net/ggdhs/article/details/90713154)

3. 上面那种方法太复杂，假设字符串长度为`n`，首先需要找到最长公共子串，这需要`O(n^2)`的时间复杂度，`O(n^2)`的空间复杂度，其次，若果找到的不匹配，则需要标记并重新寻找。

4. 直接采用动态规划的方法，定义`P(i,j)`，如果子串`Si,...,Sj`是回文串，`P(i,j) = true`，否则为`false`。则有：`P(i,i) = true`，当`Si == Si+1`时，`P(i,i+1) == true`。所以，当`P(i+1,j-1) == true`且`Si == Sj`时，`P(i,j) = true`。这种方法的时间复杂度为`O(n^2)`，空间复杂度为`O(n^2)`。

5. 考虑回文串的性质，可以从中间某个子符或者某两个字符往两边展开，判断是否是回文串，这样的中心点至多有`2n-1`个（包括一个字符和两个字符的情况）。这种方法的时间复杂度为`O(n^2)`，空间复杂度为`O(1)`。可以考虑实现。

6. 还有时间复杂度为`O(n)`，空间复杂度为`O(n)`的算法：[Manacher's Algorithm](https://leetcode.com/articles/palindromic-substrings/) [中文版](https://www.cnblogs.com/grandyang/p/4475985.html)
---