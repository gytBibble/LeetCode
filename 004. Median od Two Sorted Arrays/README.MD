# 题目
* 找到两个排序数组（从小到大，长度分别为`m`和`n`）的中位数,要求复杂度至多为`O(log (m+n))`
---
# 思路
## C++
1. 首先考虑归并排序当中的`merge`操作，将两个数组合并，然后取中位数，复杂度在`O(m+n)`，超出题目要求。
2. 很明显，要达到题目要求的复杂度，需要使用二分的方法。由于数组是有序的，我们在寻找第`K`大的数时，由于有两个数组，我们每次可以排除掉`K/2`个数。  
对于两个数组：`A[1],A[2],A[3],...,A[k/2]...`，`B[1],B[2],B[3],...,B[k/2]...`，如果`A[k/2]<B[k/2]`，那么`A[1],A[2],A[3]...A[k/2]` 都不可能是第`k`小的数字。数组A中比`A[k/2]`小的数有`k/2-1`个，数组B中，`B[k/2]`比`A[k/2]`小，假设`B[k/2]`前边的数字都比`A[k/2]` 小，也只有`k/2-1`个，所以比`A[k/2]`小的数字最多有`k/2-1+k/2-1 = k-2`个，所以`A[k/2]`最多是第`k-1`小的数。而比`A[k/2]`小的数更不可能是第`k`小的数了，所以可以把它们排除。  
那么，题目就转换为了找到两个数组的第`K`个数，采用递归的方法求解，每次递归只在一个数组上操作。每进行一次递归，我们就减少`k/2`个元素，所以时间复杂度是`O(log k)`，而 `k = (m+n)/2`，所以最终的复杂也就是`O(log (m + n))`。
3. 事实上，还有复杂度更低的方法，为`O(log (min(m,n)))`，参考：[英文版](https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2481/Share-my-O(log(min(mn)))-solution-with-explanation) 以及 [中文版](https://zhuanlan.zhihu.com/p/70654378)